# Metrics监控

## Introduction

**「What」**Prometheus是一套开源系统监控与警报的工具包。Prometheus 将其指标收集并存储为时间序列数据，即指标信息与记录的时间戳一起存储，以及称为标签的可选键值对。

Prometheus受启发于Google的Brogmon监控系统（相似的Kubernetes是从Google的Brog系统演变而来），从2012年开始由前Google工程师在Soundcloud以开源软件的形式进行研发，并且于2015年早期对外发布早期版本。2016年5月继Kubernetes之后成为第二个正式加入CNCF基金会的项目，同年6月正式发布1.0版本。2017年底发布了基于全新存储层的2.0版本，能更好地与容器平台、云平台配合。

![Image](https://cdn.jsdelivr.net/gh/edgarding77/microservice-platform-doc@latest/image/func/prometheus-history.png)

## 监控的目标

在《SRE: Google运维解密》一书中指出，监控系统需要能够有效的支持***白盒监控***与***黑盒监控***。

- 通过白盒能够了解其内部的实际运行状态，通过对监控指标的观察能够预判可能出现的问题，从而对潜在的不确定因素进行优化。
- 而黑盒监控，常见的如HTTP探针，TCP探针等，可以在系统或者服务在发生故障时能够快速通知相关的人员进行处理。

通过以上达到以下目的：

- 长期趋势分析：通过对监控样本数据的持续收集和统计，对监控指标进行长期趋势分析。例如，通过对磁盘空间增长率的判断，我们可以提前预测在未来什么时间节点上需要对资源进行扩容。
- 对照分析：两个版本的系统运行资源使用情况的差异如何？在不同容量情况下系统的并发和负载变化如何？通过监控能够方便的对系统进行跟踪和比较。
- 告警：当系统出现或者即将出现故障时，监控系统需要迅速反应并通知管理员，从而能够对问题进行快速的处理或者提前预防问题的发生，避免出现对业务的影响。
- 故障分析与定位：当问题发生后，需要对问题进行调查和处理。通过对不同监控监控以及历史数据的分析，能够找到并解决根源问题。
- 数据可视化：通过可视化仪表盘能够直接获取系统的运行状态、资源使用情况、以及服务运行状态等直观的信息。

## 为什么选择Pormetheus？

Prometheus基本原理是通过HTTP协议周期性抓取被监控组件的状态，这样做的好处是任意组件只要提供HTTP接口就可以接入监控系统，不需要任何SDK或者其他的集成过程。这样做非常适合虚拟化环境比如VM或者Docker 。

Prometheus应该是为数不多的适合Docker、Mesos、Kubernetes环境的监控系统之一。输出被监控组件信息的HTTP接口被叫做exporter 。目前互联网公司常用的组件大部分都有exporter可以直接使用，比如Varnish、Haproxy、Nginx、MySQL、Linux 系统信息 (包括磁盘、内存、CPU、网络等等)，具体支持的源看：https://github.com/prometheus。

与其他监控系统相比，Prometheus的主要特点是：

- 一个多维数据模型（时间序列由指标名称定义和设置键/值尺寸）。
- 非常高效的存储，平均一个采样数据占~3.5bytes左右，320万的时间序列，每30秒采样，保持60天，消耗磁盘大概228G。
- 一种灵活的查询语言。
- 不依赖分布式存储，单个服务器节点。
- 时间集合通过HTTP上的PULL模型进行。
- 通过中间网关支持推送时间。
- 通过服务发现或静态配置发现目标。
- 多种模式的图形和仪表板支持。

Prometheus的优势在于：

- 易于管理：Prometheus仅有单独的二进制文件，不存在任何第三方依赖（数据库、缓存等），仅需要本地磁盘；同时Prometheus基于pull模型的架构方式，可以任何地方搭建我们的监控系统。
- 监控服务内部的运行状态：基于Prometheus丰富的Client库，用户可以轻松的在应用程序中添加对Prometheus的支持，从而让用户获取服务和应用内部的真正运行状态。
- 强大的数据模型：所有采集的监控数据均以指标(metric)的形式保存在内置的时间序列数据库当中(TSDB)。所有的样本除了基本的指标名称以外，还包含一组用于描述该样本特征的标签。
- 强大的查询语言：通过PromQL实现对监控数据的查询和聚合。
- 高效：百万级别的监控指标，每秒处理数十万的数据点。
- 易于集成：可以很方便的在应用程序中进行集成，社区庞大有着许多第三方实现。
- 可视化
- 开放性：提供开放性的监控协议支持。

## Prometheus架构

![img](https://cdn.jsdelivr.net/gh/edgarding77/microservice-platform-doc@latest/image/func/prometheus-arch.png)

- 它的服务过程是这样的Prometheus daemon负责定时去目标上抓取metrics(指标) 数据，每个抓取目标需要暴露一个http服务的接口给它定时抓取。
- Prometheus：支持通过配置文件、文本文件、zookeeper、Consul、DNS SRV lookup等方式指定抓取目标。支持很多方式的图表可视化，例如十分精美的Grafana，自带的Promdash，以及自身提供的模版引擎等等，还提供HTTP API的查询方式，自定义所需要的输出。
- Alertmanager：是独立于Prometheus的一个组件，可以支持Prometheus的查询语句，提供十分灵活的报警方式。
- PushGateway：这个组件是支持Client主动推送metrics到PushGateway，而Prometheus只是定时去Gateway上抓取数据。
- 大多数Prometheus组件都是用Go编写的，它们可以轻松地构建和部署为静态二进制文件。访问[prometheus.io](https://prometheus.io/)以获取完整的文档，示例和指南。

## 补充

**「Issue」什么是黑/白盒监控？**

黑盒监控指的是监控外部用户可见的系统行为，白盒监控指的是监控内部暴露出来的指标信息。它们一个对外，一个对内。二者在功能上有 2 点区别。

- 监控角度不同：黑盒更偏向于外侧，你可以理解为是通过某个功能或者具体的某个接口来观察，它并不清楚内部是如何实现的；而白盒则更倾向于从内侧监控，它是代码层面的，从内部的视角来解读整个系统。
- 面向对象不同：黑盒更倾向于看到这个问题的现象，比如某个端口挂掉了无法再提供服务，它面向的是当下所发生的故障；白盒则更加倾向于面向产生问题的原因，比如我们在日志中可以通过堆栈信息分析出故障的根源。

白盒监控有时是面向问题，有时是面向问题的原因的，它的监控对象会根据监控的内容改变。假设白盒在接口层反映接口耗时比较长，此时可以认定白盒面向的是“耗时长”这一问题。但同时，白盒监控也会监控到与这个接口相关联的数据库出现了严重的慢查询。慢查询是接口耗时较长的原因，这时候我们就可以认定白盒是面向原因的。

## Reference

- https://www.prometheus.wang/
- https://www.kancloud.cn/zlt2000/microservices-platform/964114
- 黑白盒问题：https://edgar615.github.io/monitor-black.html