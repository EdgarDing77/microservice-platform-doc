# 登陆认证

## Introduction

认证Token主要有三种方式：

1. jwt
2. db
3. redis

若使用jwt方式，因为jwt使用的是非对称加密，所以认证服务djj-uua需要配置成`authJwt`为私钥加密，其他服务（例如网关）配置为`resJwt`为公钥解密。

token认证方式修改通过：

```yml
djj:
	oauth2:
		token:
			store:
				type: authJwt # redis, db, authJwt | resJwt(除认证服务外其他服务)
```

本项目是api网关统一认证的架构，适配有网络隔离的环境下使用。

## 访问请求

```bash
http://127.0.0.1:9000
admin/admmin
```

访问后端API需要带上Token

```
# 放header方式：
Authorization:Bearer xxx

# 放参数方式：
http://localhost:9900/api-user/users?access_token=xxx
```

前端具体请求构造：

```javascript
 /* 表单提交 */
        form.on('submit(loginSubmit)', function (obj) {
            layer.load(2, {time: 10 * 1000});
            $.ajax({
                url: config.base_server + 'api-uaa/oauth/token',
                type: 'POST',
                xhrFields: {
                    withCredentials: true
                },
                data: obj.field,
                beforeSend: function (xhr) {
                    xhr.setRequestHeader('Authorization', 'Basic ' + window.btoa(config.clientId + ":" + config.clientSecret));
                },
                success: function (response) {
                    console.log(JSON.stringify(response));
                    if (response.resp_code === 0) {
                        config.putToken(response.data);
                        // icon：-1 信息框 /0 加载框
                        layer.msg('登录成功', {icon: 1, time: 500},function () {
                            location.replace("./");
                        });
                    } else {
                        // 关闭所有加载层
                        layer.closeAll('loading');
                        layer.msg(response.resp_msg, {icon: 5, time: 500});
                    }
                },
                error: function (xhr) {
                    console.log(JSON.stringify(xhr));
                    layer.closeAll('loading');
                    layer.msg(xhr.responseJSON.resp_msg, {icon: 5, time: 500});
                }
            });
            // 阻止表单跳转
            return false;
        });
```



## token自动续签

本设计只针对redis token，该模式续签只会修改过期时间而不重新生成token，因为重新生成一个token会导致同一个账户下的其他客户端访问失效。

> 续签会有性能开销，所以设计了开关和黑白名单方便灵活控制，只有真正需要的业务才开放

![img](https://cdn.jsdelivr.net/gh/edgarding77/microservice-platform-doc@latest/image/func/redis-token-flow.png)

这里对RedisTokenStore进行重定制，具体类查看`{@link top.edgarding.infrastructure.authclient.store.CustomRedisTokenStore}`：

续签配置具体说明：

```yml
djj:
	security:
		auth:
			renew: # token自动续签配置
				enable: false # 默认为false
				includeClientIds: # 白名单，配置自动续签的id，不配置默认所有应用生效
        exclusiveClientIds: # 黑明单，配置不需要自动续签的AppId
        timeRatio: 0.5 # 默认0.5 续签时间比例，当前剩余时间小于过期总时长的50%则续签
```

- enable：全局Token续签配置是否开启
- includeClientIds&exclusiveClientIds：若两个都存在相同的clientId配置，则以黑名单为主即不开启自动续签。
- timeRatio：计算公式`currentTime - expireTime / expireTime - createTime`。

## URL级权限认证

url级权限配置：

## 登录方式

### 自定义方式

目前实现方式有：

- grant_type = password_code：username + password + validate code验证模式

#### password_code

该模式为对原有授权逻辑password的加强。使用username、password和validate code，实现网页验证模式。

扩展说明：

1. 添加一个新的grantType类型，并增加到对应的`TokenGranter`实现类，添加扩展内容。（具体方式：`PasswordCodeGranter extends ResourceOwnerPasswordTokenGranter`）
2. 然后加到`CompositeTokenGranter` 中的 `tokenGranters` 集合里即可。

增加校验逻辑即可：

```java
public class PasswordCodeGranter extends ResourceOwnerPasswordTokenGranter {
    private static final String GRANT_TYPE = "password_code";

    private final ValidateCodeService validateCodeService;

    public PasswordCodeGranter(AuthenticationManager authenticationManager, AuthorizationServerTokenServices tokenServices
        , ClientDetailsService clientDetailsService, OAuth2RequestFactory requestFactory, ValidateCodeService validateCodeService) {
        super(authenticationManager, tokenServices, clientDetailsService, requestFactory, GRANT_TYPE);
        this.validateCodeService = validateCodeService;
    }

    @Override
    protected OAuth2Authentication getOAuth2Authentication(ClientDetails client, TokenRequest tokenRequest) {
        Map<String, String> parameters = new LinkedHashMap<>(tokenRequest.getRequestParameters());
      	// 在此添加拓展内容 校验逻辑即可
        String deviceId = parameters.get("deviceId");
        String validCode = parameters.get("validCode");
        validateCodeService.validate(deviceId, validCode);

        return super.getOAuth2Authentication(client, tokenRequest);
    }
}

```

这里详解下校验码的逻辑：

- 网页逻辑：

  ```java
      @Override
      public String createCode(String deviceId) {
          String code = RandomUtil.randomNumbers(SecurityConstants.VALIDATE_CODE_SIZE);
          redisRepository.setExpire(redisKey(deviceId), code,
              SecurityConstants.VALIDATE_CODE_EXPIRE);
          return code;
      }
  ```

- 手机逻辑：（该功能没法具体实现，只是实现逻辑）

  1. 先去redis 查询是否 60S内已经发送
  2. 未发送： 判断手机号是否存在 ? false :产生4位数字  手机号-验证码
  3. 发往消息中心-》发送信息
  4. 保存redis

  ```java
      @Override
      public CommonResult sendSmsCode(String mobile) {
          String tempCode = (String) redisRepository.get(redisKey(mobile));
          if (tempCode != null) {
              log.error("用户:{}验证码未失效{}", mobile, tempCode);
              return CommonResult.failed("验证码未失效，请失效后再次申请");
          }
  
          SysUser user = userService.findByMobile(mobile);
          if (user == null) {
              log.error("根据用户手机号 {} 查询用户为空", mobile);
              return CommonResult.failed("手机号不存在");
          }
  
          String code = RandomUtil.randomNumbers(SecurityConstants.VALIDATE_CODE_SIZE);
          log.info("短信发送请求消息中心 -> 手机号:{} -> 验证码：{}", mobile, code);
          redisRepository.setExpire(redisKey(mobile), code, SecurityConstants.VALIDATE_CODE_EXPIRE);
          return CommonResult.succeed("true");
      }
  ```

### 密码 - 验证码授权模式

请求API：`localhost:9001/users/saveOrUpdate`

```json
{
    "data": {
        "id": 1,
        "createTime": "2021-12-26T05:47:54.777+00:00",
        "updateTime": "2021-12-26T05:47:54.777+00:00",
        "username": "admin",
        "password": "{bcrypt}$2a$10$H5iFnJeqVtYmrx1d6XsNBOIRZB0LBvGLUpH2j2inDbhhP45q3yyJG",
        "nickname": "管理员",
        "headImgUrl": null,
        "mobile": "15112343188",
        "sex": null,
        "type": "ADMIN",
        "openId": null,
        "isEnable": true,
        "isDel": null,
        "roles": null,
        "roleId": null,
        "oldPassword": null,
        "newPassword": null
    },
    "responseCode": 0,
    "responseMsg": "操作成功"
}
```



## 

## 登录认证逻辑说明



## Reference