# 分布式日志链路追踪

## Introduction

**「What」**追踪（Tracing）：单体系统时代追踪的范畴基本只局限于[栈追踪](https://en.wikipedia.org/wiki/Stack_trace)（Stack Tracing），调试程序时，在 IDE 打个断点，看到的 Call Stack 视图上的内容便是追踪；编写代码时，处理异常调用了 `Exception::printStackTrace()`方法，它输出的堆栈信息也是追踪。微服务时代，追踪就不只局限于调用栈了，一个外部请求需要内部若干服务的联动响应，这时候完整的调用轨迹将跨越多个服务，同时包括服务间的网络传输信息与各个服务内部的调用堆栈信息，因此，分布式系统中的追踪在国内常被称为“全链路追踪”（后文就直接称“链路追踪”了），许多资料中也称它为“[分布式追踪](https://opentracing.io/docs/overview/what-is-tracing/)”（Distributed Tracing）。

追踪的主要目的是排查故障，如分析调用链的哪一部分、哪个方法出现错误或阻塞，输入输出是否符合预期，等等。

日志链路追踪主要通过日志进行定位，因为大量的用户/线程日志也输出穿插其中，很难筛选出指定请求的全部相关日志，以及下游线程/服务对应的日志。

## 解决思路

- 每个请求都是用**唯一标识**来追踪全部的链路显示在日志中，并且不修改原有的打印方式（代码无入侵）。
- 使用Logback的`MDC`机制日志模版中加入`traceId`标识，取值方式为`%X{traceId}`。

`traceId`：全局id，整个请求链路标识，链路中的所有请求都会带上

`MDC`：MDC（Mapped Diagnostic Context，映射调试上下文），及将一些运行时的上下文数据通过logback打印出来，是一种方便在多线程条件下记录日志的功能。

> MDC（Mapped Diagnostic Context，映射调试上下文）是 log4j 和 logback 提供的一种方便在多线程条件下记录日志的功能。MDC 可以看成是一个与当前线程绑定的Map，可以往其中添加键值对。MDC 中包含的内容可以被同一线程中执行的代码所访问。当前线程的子线程会继承其父线程中的 MDC 的内容。当需要记录日志时，只需要从 MDC 中获取所需的信息即可。MDC 的内容则由程序在适当的时候保存进去。对于一个 Web 应用来说，通常是在请求被处理的最开始保存这些数据。

## 方案实现

由于MDC内部使用的是`ThreadLocal`，所以只有在本线程内有效，子线程和下游服务的MDC的值将会被丢失；因此方案的主要难点在于：**解决值传递问题**，主要包括如下：

- API网关中的MDC数据如何传递给下游服务
- 服务如何接受数据，并且调用其他远程服务时如何继续传递
- 异步情况下（线程池）如何传给子线程

traceId创建方式：`UUID.randomUUID().toString().replace("-", "").toUpperCase();`即UUID的方式。

header：`x-traceId-header`

修改日志模版：

```xml
<property name="CONSOLE_LOG_PATTERN"
              value="[${APP_NAME}:${ServerIP}:${ServerPort}] ...%clr([%X{traceId}]){yellow}..." />

```

### 1、网关过滤器

生成`traceId`并通过`header`传递给下游服务，该文件位于网关下的filter包，优先级最高，是整个系统的第一个filter。

```java
/**
 * Description:
 * 生成日志链路追踪id，并传入header中
 * 继承Ordered使其拥有最高的优先级
 *
 * @author:edgarding
 * @mail:edgarding97@gmail.com
 * @date:2021/12/3
 **/
@Component
public class TraceFilter implements GlobalFilter, Ordered {
    @Autowired
    TraceProperties traceProperties;

    @Override
    public Mono<Void> filter(ServerWebExchange exchange, GatewayFilterChain chain) {
        if (traceProperties.getEnable()) {
            String traceId = MDCTraceUtil.createTraceId();
            MDC.put(CommonConstants.LOG_TRACE_ID, traceId);
            ServerHttpRequest httpRequest = exchange.getRequest().mutate()
                .header(CommonConstants.LOG_TRACED_ID_HEADER, traceId)
                .build();

            ServerWebExchange serverWebExchange = exchange.mutate()
                .request(httpRequest)
                .build();
            
            return chain.filter(serverWebExchange);
        }
        return chain.filter(exchange);
    }

    @Override
    public int getOrder() {
        return Ordered.HIGHEST_PRECEDENCE;
    }
}

```

### 2、下游服务增加Spring拦截器

接收并保存`traceId`的值，该文件地址为：djj-log-spring-boot-starter模块下的/log/trace/WebTraceFilter.java。

```java
@ConditionalOnClass({HttpServletRequest.class, OncePerRequestFilter.class})
@Order(value = MDCTraceUtil.FILTER_ORDER)
public class WebTraceFilter extends OncePerRequestFilter {
    @Resource
    TraceProperties traceProperties;

    @Override
    protected boolean shouldNotFilter(HttpServletRequest request) throws ServletException {
        return !traceProperties.getEnable();
    }

    @Override
    protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response,
                                    FilterChain filterChain) throws ServletException, IOException {
        try {
            String traceId = request.getHeader(MDCTraceUtil.TRACE_ID_HEADER);
            if (traceId == null || traceId.length() == 0) {
                MDCTraceUtil.addTraceId();
            } else {
                // 存在则更新
                MDCTraceUtil.putTraceId(traceId);
            }
            filterChain.doFilter(request, response);
        } finally {
            MDCTraceUtil.removeTraceId();
        }
    }
}
```

这里需要注意为服务注册拦截器，在WebMvcConfig中进行拦截器的添加。

项目中使用spring.factories直接自动注册配置。

### 3、下游服务添加Feign拦截器

继续将当前服务的`traceId`传递给下游服务

```java
/**
 * Description:
 * feign拦截器，传递traceId，传递给下游服务
 * @author:edgarding
 * @mail:edgarding97@gmail.com
 * @date:2021/12/3
 **/
@ConditionalOnClass(RequestInterceptor.class)
public class FeignTraceInterceptor {
    @Resource
    private TraceProperties traceProperties;
    
    @Bean
    public RequestInterceptor feignTraceInterceptor() {
        return template -> {
            if (traceProperties.getEnable()) {
                // 传递traceId
                String traceId = MDCTraceUtil.getTraceId();
                if (!(traceId == null || traceId.length() == 0)) {
                    template.header(MDCTraceUtil.TRACE_ID_HEADER, traceId);
                }
            }
        };
    }
}
```

### 4、父子线程传递问题

主要针对业务会使用线程池(异步、并行处理)，并且`spring`自己也有`@Async`注解来使用线程池，要解决这个问题需要以下两个步骤：

#### 4.1、修改logback的`LogbackMDCAdapter`

由于logback的`MDC`实现内部使用的是`ThreadLocal`不能传递子线程，所以需要重写替换为阿里的`TransmittableThreadLocal`。

这里`TransmittableThreadLocal`具体参考技术文档中的[Transmittable-ThreadLocal]()文档。

> **TransmittableThreadLocal** 是Alibaba开源的、用于解决 **“在使用线程池等会缓存线程的组件情况下传递ThreadLocal”** 问题的 InheritableThreadLocal 扩展。若希望 TransmittableThreadLocal 在线程池与主线程间传递，需配合 **TtlRunnable** 和 **TtlCallable** 使用。

这里可以使用现有的具体参考[`Logback MDC`的`TTL`集成](https://github.com/alibaba/transmittable-thread-local/blob/master/docs/requirement-scenario.md#logback-mdc%E7%9A%84ttl%E9%9B%86%E6%88%90)。

logback-mdc-ttl：https://github.com/ofpay/logback-mdc-ttl

```xml
<dependency>
    <groupId>com.ofpay</groupId>
    <artifactId>logback-mdc-ttl</artifactId>
    <version>1.0.2</version>
</dependency>
```

这里免得引入依赖，直接重写文件，同时这里其实只是更改如下：

```java
final ThreadLocal<Map<String, String>> copyOnInheritThreadLocal = new TransmittableThreadLocal<>();
```

其他都是和`ch.qos.logback.classic.util.LogbackMDCAdapter`一样，只是改为调用`copyOnInheritThreadLocal`变量。

通过实现`ApplicationContextInitializer`接口，通过`initialize`初始化在程序启动时加载自己的MdcAdapter实现。

重写参考：[欧飞网的使用场景](https://github.com/alibaba/transmittable-thread-local/issues/73#issuecomment-300665308)

#### 4.2、拓展线程池实现

增加`TtlRunnable`和`TtlCallable`扩展

```
public class CustomThreadPoolTaskExecutor extends ThreadPoolTaskExecutor {
    @Override
    public void execute(Runnable runnable) {
        Runnable ttlRunnable = TtlRunnable.get(runnable);
        super.execute(ttlRunnable);
    }

    @Override
    public <T> Future<T> submit(Callable<T> task) {
        Callable ttlCallable = TtlCallable.get(task);
        return super.submit(ttlCallable);
    }

    @Override
    public Future<?> submit(Runnable task) {
        Runnable ttlRunnable = TtlRunnable.get(task);
        return super.submit(ttlRunnable);
    }

    @Override
    public ListenableFuture<?> submitListenable(Runnable task) {
        Runnable ttlRunnable = TtlRunnable.get(task);
        return super.submitListenable(ttlRunnable);
    }

    @Override
    public <T> ListenableFuture<T> submitListenable(Callable<T> task) {
        Callable ttlCallable = TtlCallable.get(task);
        return super.submitListenable(ttlCallable);
    }
}
```

## Reference

- 《凤凰架构》
- https://juejin.cn/post/6844904046139015182
- logback的MDC：https://blog.csdn.net/bigtree_3721/article/details/89494550
- 案例：https://cloud.tencent.com/developer/article/1621712
- 父子线程传递问题：https://www.cnblogs.com/yangyongjie/p/12523567.html
- 实现方案：https://mp.weixin.qq.com/s/xoaXUnzOdK-RaBYOGbYmqw
- 欧飞网使用场景：https://github.com/alibaba/transmittable-thread-local/issues/73#issuecomment-300665308

