# 分布式锁

[toc]

## Introduction

线程是OS运行调度的最小单位，单体系统下，为了多线程之间的线程安全JDK提供了sychronized和JUC包。但是它们都统一的限制，竞争资源的线程，都是运行在同一个Jvm进程下Redis锁，在分布式架构中，不同Jvm进程是无法使用该锁的。

为了防止分布式系统中多个线程之间互相干扰，需要一种分布式协调技术来对不同物理机上的进程进行协调同步，该方式的核心就是**分布式锁**。

**案例：**

100件库存的商品，其抢购的逻辑可简单分为：

1. 查询库存是否>0
2. 当库存>0，购买

当库存只剩1的时候，A用户和B用户同时执行(1)，若不依靠分布式锁，其抢购的接口为集群服务，这时候AB用户的请求分别请求到了不同的机器上，而这些服务都完成了(2)，则形成了超卖的问题。

## 分布式锁对比

常见的分布式锁有三种：

1. 数据库锁：通过数据库中的悲观锁和乐观锁实现
2. zookeeper的分布式锁：分布式共识算法
3. redis分布式锁：核心为`setnx`

对比：

不过在分布式锁的领域，还是zookeeper更专业。redis本质上也是数据库，所有其它两种方案都是“兼职”实现分布式锁的，效果上没有zookeeper好。

1. 性能消耗小：当真的出现并发锁竞争时，数据库或redis的实现基本都是通过阻塞，或不断重试获取锁，有一定的性能消耗。而zookeeper锁是通过注册监听器，当某个程序释放锁是，下一个程序监听到消息再获取锁。
2. 锁释放机制完善：如果是redis获取锁的那个客户端bug了或者挂了，那么只能等待超时时间之后才能释放锁；而zk的话，因为创建的是临时znode，只要客户端挂了，znode就没了，此时就自动释放锁。
3. 集群的强一致性：众所周知，zookeeper是典型实现了 CP 事务的案例，集群中永远由Leader节点来处理事务请求。而redis其实是实现 AP 事务的，如果master节点故障了，发生主从切换，此时就会有可能出现锁丢失的问题。

锁的必要条件：

1. 互斥性：任意时刻，只有一个客户端能持有锁。
2. 不会发生死锁：即使有一个客户端持有锁崩溃，也能保证后续其他客户端能获取到该锁。
3. 锁持有并等待：加锁与解锁必须是同一客户端，且不可抢夺其他客户端锁。 

死锁问题：

1. 共享资源时间不正确，导致业务未处理完，key就过期
2. 一个客户端释放了其他客户端持有的锁（通过id属性解决，解铃人还需系玲人）

## Redis锁

前提条件引入依赖：

```xml
<dependency>
  <groupId>top.edgarding</groupId>
  <artifactId>djj-redis-spring-boot-starter</artifactId>
</dependency>
```

配置文件有匹配的环境变量：配置为redis的方式

```YAML
djj:
  lock:
    type: redis
```

锁的重要参数：

1. key
2. value：UserID，通过传入RequestId，来保证请求锁的客户端来释放该锁（用于校对是否可以释放锁），具体可以通过UUID来记录
3. NX：Redis实现的关键，SET IF NOT EXIST，当key不存在进行set操作，当存在则不进任何操作
4. EXPX：key的过期时间，自动释放
5. time：锁释放时间

## 编码方式与注解方式

### 具体实现

使用锁的方式主要通过两种：

- 注解的方式@Lock
- 编码的方式

锁注解的方式实现（注解在类上，则所有方法加锁）：

```java
@Target({ElementType.METHOD, ElementType.TYPE})
@Retention(RetentionPolicy.RUNTIME)
@Documented
public @interface Lock {
    /**
     * 锁的key
     */
    String key();
    /**
     * 获取锁的最大尝试时间(单位 {@code unit})
     * 该值大于0则使用 locker.tryLock 方法加锁，否则使用 locker.lock 方法
     */
    long waitTime() default 0;
    /**
     * 加锁的时间(单位 {@code unit})，超过这个时间后锁便自动解锁；
     * 如果leaseTime为-1，则保持锁定直到显式解锁
     */
    long leaseTime() default -1;
    /**
     * 参数的时间单位
     */
    TimeUnit unit() default TimeUnit.SECONDS;
    /**
     * 是否公平锁
     */
    boolean isFair() default false;
}
```

锁对象具体结构，通过实现`AutoCloseable`重载`close()`来实现资源的释放，其具体实现如下：

```java
@AllArgsConstructor
public class DLock implements AutoCloseable{
    @Getter
    private final Object lock;

    private final DistributedLock locker; # 通过使用该接口实现对锁对象的操作

    @Override
    public void close() throws Exception {
        locker.unlock(lock);
    }
}
```

### 使用案例

```java
/**
* 用于代替jdk的`synchronized`和`Lock`
*/
@Autowired
private DistributedLock locker;

public void test1() {
 		try(DLock lock = locker.tryLock("lockKey", 10, TimeUtil.SECONDS)) {
      if(lock != null) {
        	//业务逻辑
      } else {
        trow new LockException("锁超时");
      }
    } 
}

@Lock(key = "test", waitTime = 10)
public void test2() {}
```

## Reference

- Redis分布式锁：https://mp.weixin.qq.com/s/RViDM1WHE61SDLNKzUmTAg
- https://segmentfault.com/a/1190000037798450
- 《凤凰架构》