# 缓存操作

### @Cacheable

@Cacheable 注解在方法上，表示该方法的返回结果是可以缓存的。也就是说，该方法的返回结果会放在缓存中，以便于以后使用相同的参数调用该方法时，会返回缓存中的值，而不会实际执行该方法。

**注意，这里强调了一点：参数相同。**这一点应该是很容易理解的，因为缓存不关心方法的执行逻辑，它能确定的是：对于同一个方法，如果参数相同，那么返回结果也是相同的。但是如果参数不同，缓存只能假设结果是不同的，所以对于同一个方法，你的程序运行过程中，使用了多少种参数组合调用过该方法，理论上就会生成多少个缓存的 key（当然，这些组合的参数指的是与生成 key 相关的）。

具体参考：https://www.cnblogs.com/coding-one/p/12401630.html

## 缓存逻辑

### 获取操作：

1. 先查库
2. 不为空，则写入缓存

### 插入操作：

**细粒度分布式锁+select+insert**

先加一个细粒度的分布式锁，然后select查一下是否存在，不存在再进行insert

- 优点：性能影响较少，使用的是细粒度锁，所以只有重复提交记录才会阻塞
- 缺点：写操作会增加一次select开销，实现难度相对较大因为需要分布式细粒度锁

```java
    @Override
    public boolean saveIdempotency(T entity, DistributedLock locker, String lockKey,
                                   Wrapper<T> countWrapper, String msg) throws Exception {
        if (locker == null) {
            throw new LockException("DistributedLock is null");
        }
        if (StrUtil.isEmpty(lockKey)) {
            throw new LockException("lockKey is null");
        }
        try (
            DLock lock = locker.tryLock(lockKey, CommonConstants.DEFAULT_WAIT_TIME,
                CommonConstants.DEFAULT_LEASE_TIME, TimeUnit.SECONDS);
        ) {
            if (lock != null) {
                int count = super.count(countWrapper);
                if (count == 0) {
                    return super.save(entity);
                } else {
                    if (StrUtil.isEmpty(msg)) {
                        msg = "已存在";
                    }
                    throw new IdempotencyException(msg);
                }
            } else {
                throw new LockException("锁等待超时");
            }
        }
    }
```

### 更新操作：

**细粒度分布式锁+select+update**

```java
    @Override
    public boolean saveOrUpdateIdempotency(T entity, DistributedLock lock, String lockKey,
                                           Wrapper<T> countWrapper, String msg) throws Exception {
        if (entity != null) {
            TableInfo tableInfo = TableInfoHelper.getTableInfo(entity.getClass());
            if (tableInfo != null && StrUtil.isNotEmpty(tableInfo.getKeyProperty())) {
                Object idVal = ReflectionKit.getFieldValue(entity, tableInfo.getKeyProperty());
                if (StringUtils.checkValNull(idVal) ||
                    Objects.isNull(getById((Serializable) idVal))) {
                    if (StrUtil.isEmpty(msg)) {
                        msg = "已存在";
                    }
                    return this.saveIdempotency(entity, lock, lockKey, countWrapper, msg);
                } else {
                    return updateById(entity);
                }
            } else {
                throw ExceptionUtils.mpe("Error:  Can not execute. Could not find @TableId.");
            }
        }
        return false;
    }
```



### 删除操作：

1. 先删除库
2. 删除缓存