# 系统幂等性

## Introduction

**「What」就是用户对于同一操作发起的一次请求或者多次请求的结果是一致的，不会因为多次点击而产生了副作用。**举个最简单的例子，那就是支付，用户购买商品使用支付，支付扣款成功，但是返回结果的时候网络异常，此时钱已经扣了，用户再次点击按钮，此时会进行第二次扣款，返回结果成功，用户查询余额返发现多扣钱了，流水记录也变成了两条。

## 系统幂等性设计

### 确定范围

1. 请求层面：读请求、写请求
   - 读不会影响数据变化

2. 微服务层面：

   - 负载均衡

   - API网关

   - 业务逻辑层

   - 数据访问层：仅有该层影响数据的变化

因此综上：范围仅有*数据访问层*和*写请求*

### 数据访问层-写请求

1. insert：**需要**做幂等性
2. update

- 直接更新某个值：不需要
- 累加操作等计算式的更新：**需要**

1. delete：重复删除结果是一样：不需要做幂等性

## 解决方案

> 没有最优的方案只有最适合的，因为这个和业务的逻辑强相关，所以就简单列举通用的方案

#### insert幂等性方案

1. 数据库增加唯一索引

- 优点：实现简单方便
- 缺点：影响数据库性能不适合该字段会被频繁更新的场景，唯一索引比普通索引在写操作上的开销会大很多

1. insert时使用临时表查询判断

```SQL
insert into sys_user(name,password)
select 'admin', '123456' from dual
where not exists(select 1 from sys_user where name='admin');
```

- 优点：不需要创建唯一索引，语法相对通用（MySQL和Oracle）
- 缺点：写操作会增加一次子查询开销，SQL语法可读性较差

1. **细粒度分布式锁+select+insert**

先加一个细粒度的分布式锁，然后select查一下是否存在，不存在再进行insert

- 优点：性能影响较少，使用的是细粒度锁，所以只有重复提交记录才会阻塞
- 缺点：写操作会增加一次select开销，实现难度相对较大因为需要分布式细粒度锁

#### Update幂等性方案

需要结合具体业务来实现，常见场景可以通过**版本号**进行控制

- 在表中增加`version`字段

```sql
alter table sys_user add version int default 0;
```

- 然后更新的时候通过判断该`verison`来判断是否过期无效，是乐观锁的一种思路

```sql
update sys_user set age=age+1, version=version+1
where version=xx
```

## 具体实现

service实现类继承`SuperServiceImpl`，例子如下：

```java
//例子1
private final static String LOCK_KEY_USERNAME = CommonConstant.LOCK_KEY_PREFIX+"username:";
String username = sysUser.getUsername();
boolean result = super.saveIdempotency(sysUser, lock
                 , LOCK_KEY_USERNAME+username
                 , new QueryWrapper<SysUser>().eq("username", username));

//例子2
private final static String LOCK_KEY_CLIENTID = CommonConstant.LOCK_KEY_PREFIX+"clientId:";
String clientId = client.getClientId();
boolean result = super.saveOrUpdateIdempotency(client, lock
        , LOCK_KEY_CLIENTID+clientId
        , new QueryWrapper<Client>().eq("client_id", clientId)
        , clientId + "已存在");
```

## Reference