# 分布式功能

[toc]

## 分布式锁

用于代替jdk的`synchronized`和`Lock`

#### **编码方式与注解方式**

```java
@Target({ElementType.METHOD, ElementType.TYPE})
@Retention(RetentionPolicy.RUNTIME)
@Documented
public @interface Lock {
    /**
     * 锁的key
     */
    String key();
    /**
     * 获取锁的最大尝试时间(单位 {@code unit})
     * 该值大于0则使用 locker.tryLock 方法加锁，否则使用 locker.lock 方法
     */
    long waitTime() default 0;
    /**
     * 加锁的时间(单位 {@code unit})，超过这个时间后锁便自动解锁；
     * 如果leaseTime为-1，则保持锁定直到显式解锁
     */
    long leaseTime() default -1;
    /**
     * 参数的时间单位
     */
    TimeUnit unit() default TimeUnit.SECONDS;
    /**
     * 是否公平锁
     */
    boolean isFair() default false;
}
```

通过实现`AutoCloseable`重载`close()`来实现资源的释放。

```java
@AllArgsConstructor
public class DLock implements AutoCloseable{
    @Getter
    private final Object lock;

    private final DistributedLock locker;

    @Override
    public void close() throws Exception {
        locker.unlock(lock);
    }
}
```

#### Redis锁

```Java
@ConditionalOnClass(RedissonClient.class)
@ConditionalOnProperty(prefix = "djj.lock", name = "type", havingValue = "REDIS", matchIfMissing = true)
```

来实现Redis锁的选择，只有该工程引入RedissonClient，和配置文件有匹配的环境变量：在配置的时候

```YAML
djj:
  lock:
    type: redis
```

## 分布式ID生成器解决方案

### Introduction

为什么需要ID生成器？什么情况下需要它？

- 数据库水平拆分的情况下，主键由于需要作为业务标识使用，需要唯一。
- 业务编号需要暴露给用户，但是又不想被用户猜到需要被隐藏的业务编号
- 业务编号需要体现业务信息，比如订单分类订单渠道等等

ID生成器设计目标？

- 全局唯一
- 每秒可生成100W+
- 趋于递增（对索引友好）
- 高可用
- 可伸缩

### 常见解决方案

#### UUID

> UUID 是 通用唯一识别码（Universally Unique Identifier）的缩写，是一种软件建构的标准，亦为开放软件基金会组织在分布式计算环境领域的一部分。

UUID是由一组32位数的16进制数字所构成，是故UUID理论上的总数为16^32=2^128，约等于3.4 x 10^38。也就是说若每纳秒产生1兆个UUID，要花100亿年才会将所有UUID用完。

UUID的标准型式包含32个16进制数字，以连字号分为五段，形式为8-4-4-4-12的32个字符。示例： 550e8400-e29b-41d4-a716-446655440000

**每秒产生10亿笔UUID，100年后只产生一次重复的机率是50%**

- 优点：
  - 本地任意生成，没有网络消耗
  - 可以任意水平拓展
  - 生成效率高
  - 生成节点不限
- 缺点
  - 没有排序，无法保证趋势递增。
  - UUID往往是使用字符串存储，查询的效率比较低。
  - 存储空间比较大，如果是海量数据库，就需要考虑存储量的问题。
  - 传输数据量大
  - 不可读

#### 数据库自增列

可以通过设置bigint类型得到数据库自增列，在事务中通过insert操作获取主键id

- 优点
  - 可以实现ID完全递增
  - 部署简单，有DB就可以
- 缺点
  - 生成效率差，取决于数据库性能指标，每秒生成一万ID都很难
  - 依赖于数据库，如果DB发生故障，在做主从切换的时候可能会引发BUG

#### Redis生成ID

当使用数据库来生成ID性能不够要求的时候，我们可以尝试使用Redis来生成ID。这主要依赖于Redis是单线程的，所以也可以用生成全局唯一的ID。可以用Redis的原子操作 `INCR`和`INCRBY`来实现。

可以使用Redis集群来获取更高的吞吐量。假如一个集群中有5台Redis。可以初始化每台Redis的值分别是1,2,3,4,5，然后步长都是5。各个Redis生成的ID为：
 A：1,6,11,16,21
 B：2,7,12,17,22
 C：3,8,13,18,23
 D：4,9,14,19,24
 E：5,10,15,20,25
     这个，随便负载到哪个机确定好，未来很难做修改。但是3-5台服务器基本能够满足器上，都可以获得不同的ID。但是步长和初始值一定需要事先需要了。使用Redis集群也可以方式单点故障的问题。
     另外，比较适合使用Redis来生成每天从0开始的流水号。比如订单号=日期+当日自增长号。可以每天在Redis中生成一个Key，使用`INCR`进行累加。

- 优点
  - 不依赖于数据库，灵活方便，且性能优于数据库。
  - 数字ID天然排序，对分页或者需要排序的结果很有帮助。
- 缺点
  - 如果系统中没有Redis，还需要引入新的组件，增加系统复杂度。
  - 需要编码和配置的工作量比较大。

#### Twitter的snowflake算法

snowflake是Twitter开源的分布式ID生成算法，结果是一个long型的ID。其核心思想是：使用41bit作为毫秒数，10bit作为机器的ID（5个bit是数据中心，5个bit的机器ID），12bit作为毫秒内的流水号（意味着每个节点在每毫秒可以产生 4096 个 ID），最后还有一个符号位，永远是0。

![Image](https://cdn.jsdelivr.net/gh/edgarding77/microservice-platform-doc@latest/image/func/snowflake-64bit.png)

| 分段  | 作用               | 说明                           |
| ----- | ------------------ | ------------------------------ |
| 1bit  | 保留               | —                              |
| 41bit | 时间戳，精确到毫秒 | 可以支持69年的跨度             |
| 5bit  | DatacenterId       | 可以最多支持32个节点           |
| 5bit  | WorkerId           | 可以最多支持32个节点           |
| 12bit | 毫秒内的计数       | 支持每个节点每毫秒产生4096个ID |

理论上单机每秒400W+，最多每秒可以生成41亿+的ID

- 优点
  - ID趋势递增
  - 生成效率高，单机每秒400W+
  - 支持线性扩充
  - 稳定性高，不依赖DB等服务
- 缺点
  - 依赖服务器时间，如果服务器时间发生回拨，可能导致生成重复ID
  - 在单机上是递增的，但是由于涉及到分布式环境，每台机器上的时钟不可能完全同步，也许有时候也会出现不是全局递增的情况

## 分布式事务

### 同步强一致性(不推荐)

基于`tx-lcn`应用

### 同步最终一致性

基于`seata`应用

### 异步最终一致性

基于`MQ`应用

