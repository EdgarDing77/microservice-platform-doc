# 架构的演变

[toc]



2021/09/06

## 前言

以下为自己从单体架构到微服务架构，接触云原生等基础设施概念后的一些总结和记录，主要整理下服务架构的一些演变。

## 单体系统

> **单体系统的本质是：**主要过程调用都是进程内调用不会发生进程间通信。

单体系统是当前使用最广、人数最多的一种架构风格，而这个称呼也是源于微服务流行之后所形成的概念。单体系统其本身含义就是——**由同一技术平台的不同组件构成的单层软件**。这里强调的是同一技术平台，其就是指部署到一个机器上。

对于小型系统，因为单体机器就足以支撑其良好运行的系统，单体不仅易于开发、易于测试、易于部署，且各个功能、模块、方法调用都是进程内调用，不会发生IPC，是运行效率最高的一种架构风格。

在了解和学习微服务后，反过头来看单体系统，第一个想法可能就是“难以拆分，难以拓展”，也是单体系统难以支撑越来越大的软件规模的原因。但细细想想这么说有失偏颇：

- 首先几乎没有不分层的系统，无论是单体还是微服务，都会对代码进行纵向层次划分，收到的外部请求在各个层之间以不同形式的数据进行流转直到数据库。
- 从横向角度来说，单体也可以支持按照技术、功能、职责等唯独，将软件拆分为各种模块以便复用和管理。

单体的真正缺陷，可以从当今Kubernetes和Docker来想，从物理机到虚拟机，再到容器，愈发细粒度化，而单体正因为所有模块、方法调用都无需考虑网络分区、远程调用等麻烦和性能损失，因为运行在同一进程空间，当问题出现的时候也是全局性的发生，如内存泄露、线程阻塞、死循环等等问题，都会对全局造成影响，而不单单的只是影响当前出现问题的模块。这种不可隔离性，程序在出现问题或者更新发布的时候，都是需要进行专门停机发布的，且更为复杂。

若是小系统去做，则去思考微服务等架构无非小题大作，而当系统体积不断扩大，单体的缺陷也将很快暴露出来，总结如下：

- 部署的成本，技术升级的成本
- 无法很好的进行技术的异构
- 出现问题时对系统的全局性影响（没有隔离、自治的能力）

## 面向服务架构SOA

> **SOA架构（Service-Oriented Architecture）** 面向服务的架构是一次具体地、系统性地成功解决分布式服务主要问题的架构模式。

对于大型单体系统进行拆分，让每一个子系统都能独立的部署、更新、运行，有三种较有代表性的架构模式：

- **烟囱式架构（Information Silo Architecture）：**指一种完全不与其他相关信息系统进行互操作或协调工作的设计模式。这其实就是两个不发生交互的系统，使用独立的数据库和服务器进行拆分，这在我看来其实都不能说是一种“架构模式”。
- **微内核架构（Microkernel Architecture）：**指将其他子系统使用到的一些公共的主数据进行集中，成为一个被所有业务系统共同依赖的核心，具体的业务系统以插件模块的形式存在。
- **事件驱动架构（Event-Driven Architecture）：**为了让子系统互相通信，一种可行的方案就是在子系统之间建立一套事件队列管道（Event Queues），来自系统外的消息将以事件的形式发送到管道中，让各个子系统进行所需的消费。

到了事件驱动架构，就开始走向现在系统的一些特征——远程服务调用协议。

## 微服务架构

> **微服务架构（Microservices）** 微服务指通过多个小型服务组合来构建单个应用的架构风格，这些服务围绕业务能力而非特定技术标准来构建。各个服务可以根据自身需求选定所需的技术栈。

这里提下当今微服务实现的两种方案：

### Spring Cloud

Spring Cloud实现实现微服务的一套基础架构，有助于快速落地微服务架构。

Spring Cloud以Java库的形式工作，所以工作层面是在应用层（研发层）。提供来一系列的解决方案来应对微服务中各种需求和痛点。

- Eureka：提供注册与发现
- Ribbon：实现客户端的负载均衡
- Feign：将RESTful变成强类型接口调用
- Config：提供方便但不灵活的配置中心
- Hystrix：提供熔断限流方案
- Zuul：提供网关方案
- ...

Spring Cloud将实现微服务的通用能力封装到该框架中，开发者只需要使用该框架开发自己的业务代码，生成的微服务自然就内置了这些能力，即**通过SDK的方式实现了微服务**。

但是只能将Java作为技术栈开发，在集成异构技术方面限制较大，代码侵入性较强。

### Kubernetes

由于Docker的诞生和微服务的流行，Docker的特性十分适合微服务，而k8s就是进一步为了方便Docker容器进行编排。

从**基础设施**来说，docker就类似于机房中的服务器，而如何进行接网络、装系统、存放与管理等等就需要通过k8s。

从**微服务**来说，k8s通过基础设施的方式通过逻辑抽象出service等概念提供了对微服务的另一种实现。

好处在于通过在基础层上提供了抽象，对代码无侵入。但是对于微服务的治理比较弱，如熔断限流等。

从SpringCloud到K8S中：

1. 服务发现Discovery：在k8s环境中，ETCD已经拥有了服务发现所必要的信息，没有必要使用Eureka，通过Discovery就能获取k8sETCD中注册服务列表进行服务发现
2. 负载均衡：去掉Feign负载均衡，Ribbion负载均衡有Service/Pod两种，在Service模式下，可以使用K8S原生负载均衡，并通过Istio实现服务治理。
3. 网关边缘化
4. 分布式配置Config
5. 增加Prometheus监控

### 微服务的特征

以下引述下微服务的九个核心业务和技术特征：

- **围绕业务能力构建（Organized around Business Capability）**

  这里再次强调了康威定律的重要性，有怎样结构、规模、能力的团队，就会产生出对应结构、规模、能力的产品。这个结论不是某个团队、某个公司遇到的巧合，而是必然的演化结果。如果本应该归属同一个产品内的功能被划分在不同团队中，必然会产生大量的跨团队沟通协作，跨越团队边界无论在管理、沟通、工作安排上都有更高昂的成本，高效的团队自然会针对其进行改进，当团队、产品磨合调节稳定之后，团队与产品就会拥有一致的结构。

- **分散治理（Decentralized Governance）**

  这是要表达“谁家孩子谁来管”的意思，服务对应的开发团队有直接对服务运行质量负责的责任，也应该有着不受外界干预地掌控服务各个方面的权力，譬如选择与其他服务异构的技术来实现自己的服务。这一点在真正实践时多少存有宽松的处理余地，大多数公司都不会在某一个服务使用 Java，另一个用 Python，下一个用 Golang，而是通常会有统一的主流语言，乃至统一的技术栈或专有的技术平台。微服务不提倡也并不反对这种“统一”，只要负责提供和维护基础技术栈的团队，有被各方依赖的觉悟，要有“经常被凌晨 3 点的闹钟吵醒”的心理准备就好。微服务更加强调的是确实有必要技术异构时，应能够有选择“不统一”的权利，譬如不应该强迫 Node.js 去开发报表页面，要做人工智能训练模型时，应该可以选择 Python，等等。

- **通过服务来实现独立自治的组件（Componentization via Services）**

  之所以强调通过“服务”（Service）而不是“类库”（Library）来构建组件，是因为类库在编译期静态链接到程序中，通过本地调用来提供功能，而服务是进程外组件，通过远程调用来提供功能。前面的文章里我们已经分析过，尽管远程服务有更高昂的调用成本，但这是为组件带来隔离与自治能力的必要代价。

- **产品化思维（Products not Projects）**

  避免把软件研发视作要去完成某种功能，而是视作一种持续改进、提升的过程。譬如，不应该把运维只看作运维团队的事，把开发只看作开发团队的事，团队应该为软件产品的整个生命周期负责，开发者不仅应该知道软件如何开发，还应该知道它如何运作，用户如何反馈，乃至售后支持工作是怎样进行的。注意，这里服务的用户不一定是最终用户，也可能是消费这个服务的另外一个服务。以前在单体架构下，程序的规模决定了无法让全部人员都关注完整的产品，组织中会有开发、运维、支持等细致的分工的成员，各人只关注于自己的一块工作，但在微服务下，要求开发团队中每个人都具有产品化思维，关心整个产品的全部方面是具有可行性的。

- **数据去中心化（Decentralized Data Management）**

  微服务明确地提倡数据应该按领域分散管理、更新、维护、存储，在单体服务中，一个系统的各个功能模块通常会使用同一个数据库，诚然中心化的存储天生就更容易避免一致性问题，但是，同一个数据实体在不同服务的视角里，它的抽象形态往往也是不同的。譬如，Bookstore 应用中的书本，在销售领域中关注的是价格，在仓储领域中关注的库存数量，在商品展示领域中关注的是书籍的介绍信息，如果作为中心化的存储，所有领域都必须修改和映射到同一个实体之中，这便使得不同的服务很可能会互相产生影响而丧失掉独立性。尽管在分布式中要处理好一致性的问题也相当困难，很多时候都没法使用传统的事务处理来保证，但是两害相权取其轻，有一些必要的代价仍是值得付出的。

- **强终端弱管道（Smart Endpoint and Dumb Pipe）**

  弱管道（Dumb Pipe）几乎算是直接指名道姓地反对 SOAP 和 ESB 的那一堆复杂的通信机制。ESB 可以处理消息的编码加工、业务规则转换等；BPM 可以集中编排企业业务服务；SOAP 有几十个 WS-*协议族在处理事务、一致性、认证授权等一系列工作，这些构筑在通信管道上的功能也许对某个系统中的某一部分服务是有必要的，但对于另外更多的服务则是强加进来的负担。如果服务需要上面的额外通信能力，就应该在服务自己的 Endpoint 上解决，而不是在通信管道上一揽子处理。微服务提倡类似于经典 UNIX 过滤器那样简单直接的通信方式，RESTful 风格的通信在微服务中会是更加合适的选择。

- **容错性设计（Design for Failure）**

  不再虚幻地追求服务永远稳定，而是接受服务总会出错的现实，要求在微服务的设计中，有自动的机制对其依赖的服务能够进行快速故障检测，在持续出错的时候进行隔离，在服务恢复的时候重新联通。所以“断路器”这类设施，对实际生产环境的微服务来说并不是可选的外围组件，而是一个必须的支撑点，如果没有容错性的设计，系统很容易就会被因为一两个服务的崩溃所带来的雪崩效应淹没。可靠系统完全可能由会出错的服务组成，这是微服务最大的价值所在。

- **演进式设计（Evolutionary Design）**

  容错性设计承认服务会出错，演进式设计则是承认服务会被报废淘汰。一个设计良好的服务，应该是能够报废的，而不是期望得到长存永生。假如系统中出现不可更改、无可替代的服务，这并不能说明这个服务是多么的优秀、多么的重要，反而是一种系统设计上脆弱的表现，微服务所追求的独立、自治，也是反对这种脆弱性的表现。

- **基础设施自动化（Infrastructure Automation）**

  基础设施自动化，如 CI/CD 的长足发展，显著减少了构建、发布、运维工作的复杂性。由于微服务下运维的对象比起单体架构要有数量级的增长，使用微服务的团队更加依赖于基础设施的自动化，人工是很难支撑成百上千乃至成千上万级别的服务的。

## 云原生

> 从软件层面面对微服务架构问题，到软、硬结合去应对架构问题。

在微服务时代，我们通过软件去解决硬件基础设施层面的分布式问题，很大程度是因为硬件构成的基础设施，跟不上软件构成的应用服务的灵活性的无奈之举。软件只需要通过命令就可以拆分不同的服务，只用拷贝、启动就能伸缩扩容服务，而硬件的这些功能到来是**虚拟化**和**容器化**技术的到来。

这两者的一些差别和解决思路可以类比Spring Cloud和 Kubernetes的解决方案对比：

|          | Kubernetes              | Spring Cloud          |
| -------- | ----------------------- | --------------------- |
| 弹性伸缩 | Autoscaling             | N/A                   |
| 服务发现 | KubeDNS / CoreDNS       | Spring Cloud Eureka   |
| 配置中心 | ConfigMap / Secret      | Spring Cloud Config   |
| 服务网关 | Ingress Controller      | Spring Cloud Zuul     |
| 负载均衡 | Load Balancer           | Spring Cloud Ribbon   |
| 服务安全 | RBAC API                | Spring Cloud Security |
| 跟踪监控 | Metrics API / Dashboard | Spring Cloud Turbine  |
| 降级熔断 | N/A                     | Spring Cloud Hystrix  |

> 最重要的就是，但虚拟化的硬件能够跟上软件的灵活性，那些与业务无关的技术性问题便有可能从软件层面剥离，悄无声息地解决硬件基础设施之内，让软件得以只专注业务，真正“围绕业务能力构建”产品。

单纯的Kubernetes无法解决全部的分布式问题，从功能上是不如Spring Cloud方案，因为有些问题处于应用系统与基础设施的边缘，使得基础设施层面很难精细的处理。

**例子：**微服务A调用微服务B的两个服务B1和B2，若B1正常但B2出现持续的500错误，达到一定阈值之后就会对B2进行熔断，以便产生[雪崩效应](https://en.wikipedia.org/wiki/Snowball_effect)。如果在基础设施层面来解决，若切断A到B的网络通路则会影响到B1的正常调用，若不切断则会受到B2的错误影响。

上述例子，Spring Cloud这类应用代码实现的微服务并不难处理，因为使用程序来解决问题，这就有着很大的开放性。但是基础设施是针对整个容器来管理的，粒度相对粗犷，只能到容器层面，对单个远程服务就很难有效管控。同时服务的监控、认证、授权、安全、负载均衡等都有可能面临细化管理的需求，譬如服务调用时负载均衡，往往需要根据流量特征，因此为了解决这些问题——[**服务网格**](https://en.wikipedia.org/wiki/Service_mesh)。

服务网格主要通过**边车模式（Sidecar Proxy）**，其原理就是通过依附到一个Pod中agent进行第三人的流量劫持，接管了一个Pod中的对外通信流量，除了实现正常的服务间通信外*（数据平面data plane）*并且能接管控制器的命令*（控制平面control plane）*根据控制平面的配置对数据平面通信的内容进行分析处理，以实现熔断、认证、度量、监控、负载均衡等各种附加功能。

### 云应用范畴

**云应用定义与开发流程**

1. 应用定义与镜像制作
2. CI/CD
3. 消息和Streaming
4. 数据库

**云应用编排与管理**

1. 应用编排与调度
2. 服务发现与治理
3. 远程调用
4. Service Mesh

**云原生底层技术**

1. 容器运行时
2. 云原生存储技术
3. 云原生网络技术

**监控与可视化**

1. 监控
2. 日志
3. Tracing
4. 混沌工程

**云原生工具集**

1. 流程自动化与配置管理
2. 容器镜像仓库
3. 云原生安全技术
4. 云端密码管理

## 无服务架构

> **无服务架构（Serverless）** 无服务的愿景是让开发者只需要纯粹地关注业务，不需要考虑技术组件，后端的技术组件是现成的，可以直接取用，没有采购、版权和选型的烦恼；不需要考虑如何部署，部署过程完全是托管到云端的，工作由云端自动完成；不需要考虑算力，有整个数据中心支撑，算力可以认为是无限的；也不需要操心运维，维护系统持续平稳运行是云计算服务商的责任而不再是开发者的责任。

**以下引述：**

无服务现在还没有一个特别权威的“官方”定义，但它的概念并没有前面各种架构那么复杂，本来无服务也是以“简单”为主要卖点的，它只涉及两块内容：后端设施（Backend）和函数（Function）。

- **后端设施**是指数据库、消息队列、日志、存储，等等这一类用于支撑业务逻辑运行，但本身无业务含义的技术组件，这些后端设施都运行在云中，无服务中称其为“后端即服务”（Backend as a Service，BaaS）。
- **函数**是指业务逻辑代码，这里函数的概念与粒度，都已经很接近于程序编码角度的函数了，其区别是无服务中的函数运行在云端，不必考虑算力问题，不必考虑容量规划（从技术角度可以不考虑，从计费的角度你的钱包够不够用还是要掂量一下的），无服务中称其为“函数即服务”（Function as a Service，FaaS）。

## 小结

当一个架构出现痛点的时候，就会出现其解决的方案，这也本是程序员所需最重要的特质，解决问题的能力。

- 单体的复杂问题 - 微服务架构
- 微服务架构下大量应用部署和运维问题 - 容器技术
- 容器管理和调度问题 - Kubernetes
- 微服务框架的侵入性问题 - Service Mesh
- 为了让Service Mesh有更好的底层支撑 - 将Service Mesh运行在Kubernetes上

