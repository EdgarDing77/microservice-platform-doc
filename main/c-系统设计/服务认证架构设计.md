# 服务认证架构设计

## 有网络隔离

### 介绍

「What」网络隔离是指用户访问的网络环境只能访问负载均衡/API网关，而访问不了后面的微服务机器。

### 架构图

**JWT**

![Image](https://cdn.jsdelivr.net/gh/edgarding77/microservice-platform-doc@latest/image/func/network-jwt.png)

**Redis**

![Image](https://cdn.jsdelivr.net/gh/edgarding77/microservice-platform-doc@latest/image/func/network-redis.png)

### 设计思路

- **授权服务器：**负载登陆认证、token派发、token刷新、应用接入管理
- **API网关：**添加认证中心的SDK负责所有请求的鉴权，包括登陆验证和URL级别的权限判断，主要的JWT原理如下：
  1. 拦截请求获取判断是否带有token参数（parameter和header）
  2. 通过公钥pubkey.txt解密token
  3. 判断token中的权限管理信息是否能访问当前URL
  4. 把用户名和角色信息放入到请求的header中，传给后面微服务
- **TokenResolver（TokenArgumentResolver类）：**嵌入在微服务程序中负责获取当前登陆人，主要原理如下：
  1. 判断当前URL请求的方法有没有带`@LoginUser`注解
  2. 判断`@LoginUser`注解的`isFull`属性是否为`true`则通过`username`查询用户对象
  3. 构建`SysUser`对象传给目标方法

## 无网络隔离v1

### 介绍

「What」无网络隔离指用户访问的网络环境是与整个系统的部署网络环境是相同的，例如用户可以绕过API网关直接访问后台的服务。

### 架构图

**JWT**

![Image](https://cdn.jsdelivr.net/gh/edgarding77/microservice-platform-doc@latest/image/func/network-isolation-jwt.png)

**Redis**

![Image](https://cdn.jsdelivr.net/gh/edgarding77/microservice-platform-doc@latest/image/func/network-isolation-redis.png)

### 设计思路

- **统一认证**：负责登录认证、token派发、token刷新、应用接入管理等功能
- **API网关**：只负责路由转发
- **微服务**：每个服务都需加入认证中心的sdk负责所有请求的鉴权
- **TokenResolver**：嵌入在微服务程序中通过SecurityContextHolder获取当前登录人，主要原理如下：
  1. 判断当前url请求的方法有没有带有`@LoginUser`注解
  2. 判断`@LoginUser`注解的`isFull`属性是否为`true`则通过`username`查询用户对象
  3. 构建`SysUser`对象传给目标方法

## 无网络隔离v2

### 介绍

「What」无网络隔离的环境下要保证每个服务的API访问都要进行认证。

### 架构图

![Image](https://cdn.jsdelivr.net/gh/edgarding77/microservice-platform-doc@latest/image/func/network-isolation2.png)

### 设计思路

在V1的架构基础上进行改进保证每个服务的API都有认证，并且客户端与服务内部分别使用不同的token同时融合了redisToken的两者优点。

1. 客户端使用redisToken

   - **减少网络带宽消耗**：普通的uuid token对于jwt的长度小很多

   - **能实现更多的功能**：使用redisToken功能更多，能方便实现如token自动续约、在线用户列表、踢人等功能

2. 内部服务使用jwt

   - **场景符合**：由于是内部服务使用，客户端只能获取access token没有jwt，所以无需让jwt token失效符合jwt特性

   - **提升性能**：服务与服务之间的通信只需通过jwt自解析认证，无需网络连接，大大减少redis的压力和提升性能

   - **增加安全性**：内部服务与客户端所使用的token不一样，能有效防止客户端绕开网关直接请求后面服务

### 实践思路

1. 自己实现一个`RedisToken` 在`storeAccessToken` 的时候使用私钥生成JWT并存储到Redis中
2. 网关添加过滤器在认证`access_token` 成功后，获取JWT存到header中请求后面的内部服务
3. 每个内部服务都添加`@EnableResourceServer`配置为资源服务器，并且`djj.oauth2.token.store` 设置为`resJwt`使用公钥自解析JWT

## URL级权限控制

### 概述

- 该功能会有性能开销，并且会增加很多系统使用成本(大量的配置)，所以要按需开启。
- 一般有这种需求的系统都是后台管理类的2B系统，用户量和并发量并不大所以性能上的开销是可以接受的。

### 功能说明

总体包含如下几个部分：

1. 资源/菜单权限分配
2. 角色关连权限
3. 前端页面按钮资源控制显示/隐藏
4. 后台接口URL权限认证

> admin账户不受权限影响，访问所有接口

具体配置使用，前端上通过菜单管理实现对url级权限的配置：

- 菜单URL：请求的后台的URL
- 菜单路径Path：资源编码或者按钮id，用于前端页面控制元素显示/隐藏

### 缓存问题

todo

## 多用户问题

### 概述

多用户类型指的是业务中有多种类型的 **用户** ，通常不同类型的用户分别存储在不同的库表中；以淘宝为例，买家和卖家这些都是属于C端的用户，但是肯定也会存在淘宝系统的后台管理员，这个属于B端的用户，两种类型的用户肯定是分离的也就是使用不同的库表。

> 本框架的统一认证中心uaa支持多用户类型的统一授权和鉴权扩展

> 由于用户类型是业务方面的内容每个系统都不一样，框架本身不带业务相关的内容，只是提供扩展的方式与思路

只要通过`account_type`参数的值去调用对应类型的用户服务。