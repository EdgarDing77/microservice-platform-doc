# 系统幂等性

## Introduction

**「What」就是用户对于同一操作发起的一次请求或者多次请求的结果是一致的，不会因为多次点击而产生了副作用。**举个最简单的例子，那就是支付，用户购买商品使用支付，支付扣款成功，但是返回结果的时候网络异常，此时钱已经扣了，用户再次点击按钮，此时会进行第二次扣款，返回结果成功，用户查询余额返发现多扣钱了，流水记录也变成了两条。

## 系统幂等性设计

### 确定范围

1. 请求层面：读请求、写请求
   - 读不会影响数据变化

2. 微服务层面：

   - 负载均衡

   - API网关

   - 业务逻辑层

   - 数据访问层：仅有该层影响数据的变化

因此综上：范围仅有**数据访问层**和**写请求**

### 数据访问层-写请求

1. insert：**需要**做幂等性
2. update

- 直接更新某个值：不需要
- 累加操作等计算式的更新：**需要**

3. delete：重复删除结果是一样：不需要做幂等性

总结需要幂等性的操作：

- insert
- update累加更新操作

## 解决方案

> 没有最优的方案只有最适合的，因为这个和业务的逻辑强相关，所以就简单列举通用的方案

### 1、insert幂等性方案

1. 数据库增加唯一索引

- 优点：实现简单方便
- 缺点：影响数据库性能不适合该字段会被频繁更新的场景，唯一索引比普通索引在写操作上的开销会大很多

2. insert时使用临时表查询判断

```SQL
insert into sys_user(name,password)
select 'admin', '123456' from dual
where not exists(select 1 from sys_user where name='admin');
```

- 优点：不需要创建唯一索引，语法相对通用（MySQL和Oracle）
- 缺点：写操作会增加一次子查询开销，SQL语法可读性较差

3. **细粒度分布式锁+select+insert**

先加一个细粒度的分布式锁，然后select查一下是否存在，不存在再进行insert

- 优点：性能影响较少，使用的是细粒度锁，所以只有重复提交记录才会阻塞
- 缺点：写操作会增加一次select开销，实现难度相对较大因为需要分布式细粒度锁

### 2、Update幂等性方案

需要结合具体业务来实现，常见场景可以通过**版本号**进行控制

- 在表中增加`version`字段

```sql
alter table sys_user add version int default 0;
```

- 然后更新的时候通过判断该`verison`来判断是否过期无效，是乐观锁的一种思路

```sql
update sys_user set age=age+1, version=version+1
where version=xx
```

## 具体实现

在所有组件公用的djj-common-core下，实现自定义CRUD service接口：

```java
public interface IBaseService<T> extends IService<T> {
    /**
     * 幂等性新增记录 insert
     * 例子如下：
     * String username = sysUser.getUsername();
     * boolean result = super.saveIdempotency(sysUser, lock
     *                 , LOCK_KEY_USERNAME+username
     *                 , new QueryWrapper<SysUser>().eq("username", username));
     *
     * @param entity       实体对象
     * @param locker       锁实例
     * @param lockKey      锁的key
     * @param countWrapper 判断是否存在的条件
     * @param msg          对象已存在提示信息
     * @return
     */
    boolean saveIdempotency(T entity, DistributedLock locker, String lockKey, Wrapper<T> countWrapper, String msg) throws Exception;

    boolean saveIdempotency(T entity, DistributedLock locker, String lockKey, Wrapper<T> countWrapper) throws Exception;

    /**
     * 幂等性新增或更新记录
     * 存在就调用更新不存在调用插入
     * 例子如下：
     * String username = sysUser.getUsername();
     * boolean result = super.saveOrUpdateIdempotency(sysUser, lock
     *                 , LOCK_KEY_USERNAME+username
     *                 , new QueryWrapper<SysUser>().eq("username", username));
     *
     * @param entity       实体对象
     * @param locker       锁实例
     * @param lockKey      锁的key
     * @param countWrapper 判断是否存在的条件
     * @param msg          对象已存在提示信息
     * @return
     */
    boolean saveOrUpdateIdempotency(T entity, DistributedLock locker, String lockKey, Wrapper<T> countWrapper, String msg) throws Exception;

    boolean saveOrUpdateIdempotency(T entity, DistributedLock locker, String lockKey, Wrapper<T> countWrapper) throws Exception;
}
```

tips：这里获取锁的最大等待为10s（默认值），加锁时间为60s（默认值）





## Reference