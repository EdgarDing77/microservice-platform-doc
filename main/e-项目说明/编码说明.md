# 编码说明

[toc]

## 命名规则

### 模块命名

模块命名格式：

```
{prefix_name}-{module_name}
```

通用逻辑模块命名：

```
{prefix_name}-{module_name}-spring-boot-starter
```

tips：该模块为底层依赖，将被引用在具体项目模块中。

### 包命名

```
top.edgarding.{root_module_name}.{child_module_name}
```

抛开作为基础的依赖模块，其他模块的前缀均为`top.edgarding.platform`，例如网关：`top.edgarding.platform.gateway`

### 其它

文件命名：

- 图片命名：`{pictname-number}`以`-`做分割。
- 项目记录：`{year-month}`以`-`做分割。

JSR330标准：

- @Inject替代@Autowired来执行注入
- @Named替代@Component来声明一个Bean
- reference：https://elim168.github.io/spring/bean/17.对JSR330标注注解的支持.html

## 编码规范

### 编码命名

数据类型：

- boolean：`is{ObjectName}`，需要带有`is`前缀，如`isEnable`。
- Date ：`createTime`、`updateTime`分别为创建时间与更新时间

方法名：

- 更新和插入操作统一用一个方法：saveOrUpdate

### 接口规范

* 按照restful接口设计规范
  GET （SELECT）：从服务器检索特定资源，或资源列表。

  POST （CREATE）：在服务器上创建一个新的资源。

  PUT （UPDATE）：更新服务器上的资源，提供整个资源。

  PATCH （UPDATE）：更新服务器上的资源，仅提供更改的属性。

  DELETE （DELETE）：从服务器删除资源。

* 接口尽量使用名词，禁止使用动词，下面是一些例子

```java
GET         /zoos：列出所有动物园
POST        /zoos：新建一个动物园
GET         /zoos/{id}：获取某个指定动物园的信息
PUT         /zoos/{id}：更新某个指定动物园的信息（提供该动物园的全部信息）
PATCH       /zoos/{id}：更新某个指定动物园的信息（提供该动物园的部分信息）
DELETE      /zoos/{id}：删除某个动物园
GET         /zoos/{id}/animals：列出某个指定动物园的所有动物
DELETE      /zoos/{zId}/animals/{aId}：删除某个指定动物园的指定动物
```

* 反例：

```
/getAllCars
/createNewCar
/deleteAllRedCars
```

### 后端返回JSON

* 后端统一返回 com.central.common.model.Result 对象
  * data：具体响应的其他信息
  * resp_code：响应码，目前0是成功、1是失败
  * resp_msg：响应消息

### 埋点日志规范

* 如果使用日志埋点的方式，建议按以下格式写日志

```
格式为：{时间}|{来源}|{对象id}|{类型}|{对象属性(以&分割)}

例子1：
2016-07-27 23:37:23|business-center|1|user-login|ip=xxx.xxx.xx&userName=张三&userType=后台管理员

例子2：
2016-07-27 23:37:23|file-center|c0a895e114526786450161001d1ed9|file-upload|fileName=xxx&filePath=xxx
```

### 工具类说明

每个工具类util都不应该被实例化，因此在进行编写时候根据《Effictive Java》可以私有化一个构造器，来确保不能被实例化。

```java
    private ResponseUtil() {
        throw new IllegalStateException("Utility class");
    }
```

## 开发说明

### 逻辑编写

**saveOrUpdate：**

1. service接口 带有`@Transactional`
2. 是否为插入逻辑（id识别）
   1. 默认设置
3. 幂等性`saveOrUpdateIdempotency()`判断是否存在
   1. 存在则进行更新
      1. 先进行旧数据删除
   2. 不存在直接进行插入

**delete：**



### MVC开发

- Service：`extands BaseService<{model}>`
- ServiceImpl：`extends BaseServiceImpl<{mapper}, {model}> implements {service}`
- Mapper：`extends SuperMapper<{model}>`

### 依赖选用

新服务添加在djj-bussiness目录下，以下依赖直接用`<artifactId>`表示：

基础依赖（必需）：

- djj-config
- djj-common-spring-boot-starter
- djj-swagger2-spring-boot-starter
- spring-cloud-starter-alibaba-nacos-discovery：nacos自动发现
- spring-boot-starter-web：web依赖

可选依赖：

- 数据库依赖：
  - djj-db-spring-boot-starter
  - mysql-connector-java
- 缓存依赖：
  - djj-redis-spring-boot-starter
- 服务调用依赖feign：
  - djj-loadbalancer-spring-boot-starter
- 限流、熔断、降级依赖：
  - djj-sentinel-spring-boot-starter
- 服务监控依赖：
  - spring-boot-starter-actuator：暴露endpoint
  - micrometer-registry-prometheus：集成prometheus

### 配置文件

bootstrap.yml主要有以下内容（修改服务端口与服务名）：

```yaml
server:
	port: {web端口}
spring:
	application:
		name: {server_name}
```

**application.yml具体看选用的依赖。**

### 必要代码

启动类：

```java
@EnableDiscoveryClient
@EnableFeignInterceptor
@EnableFeignClients
@SpringBootApplication
public class XXXApp {
    public static void main(String[] args) {
        SpringApplication.run(XXXApp.class, args);
    }
}
```

- **@EnableDiscoveryClient**：开启服务注册发现
- **@EnableFeignInterceptor**：开启 feign 拦截器，用于服务间参数传递
- **@EnableFeignClients**：如果需要使用 feign 调用其他服务，则必需添加，并通过 basePackages 属性指定 feign 服务的包路径
- **@SpringBootApplication**：Spring Boot 应用必需

配置类：

统一异常处理

```java
@ControllerAdvice
public class ExceptionAdvice extends DefaultExceptionAdvice {
}
```

web配置

```java
@Configuration
public class WebMvcConfig extends DefaultWebMvcConfig {
}
```

用于配置 `TokenArgumentResolver` 类，解析获取当前登录人信息，并注入到方法的 `@LoginUser SysUser user` 参数里

## 数据库命名

