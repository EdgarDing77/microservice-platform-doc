# 项目细节

> 该篇记录一些项目细节

## Spring

### Spring Boot自定义配置自动提示

官方提供的spring-boot-starter的配置项带有自动提示，而自己定义的配置却没有，对开发来说十分不优化，容易打错配置。

**提示原理**

IDE是通过读取配置信息的元数据而实现自动提示的，而元数据在目录META-INF中的spring-configuration-metadata.json 或者 additional-spring-configuration-metadata.json

**具体实现**

在工程下引入依赖：

```xml
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-configuration-processor</artifactId>
    <optional>true</optional>
</dependency>
```

修改IDEA配置：

1. 搜索`Annotation Processor`并设置`Enable annotation processing`
2. 重新编译项目，项目在编译后会自动生成`spring-configuration-metadata.json`文件

**Reference**

- https://docs.spring.io/spring-boot/docs/current/reference/html/configuration-metadata.html

### Spring Factories机制

通过spring.factories实现**解耦拓展机制**。Spring Boot 应用中的”自动配置”是通过 `@EnableAutoConfiguration` 注解进行开启的。`@EnableAutoConfiguration` 可以帮助 Spring Boot 应用将所有符合条件的 `@Configuration` 配置类的 bean 都加载到 Spring IoC 容器中。

> SpringFactoriesLoader loads and instantiates factories of a given type from “META-INF/spring.factories” files which may be present in multiple JAR files in the classpath. The spring.factories file must be in Properties format, where the key is the fully qualified name of the interface or abstract class, and the value is a comma-separated list of implementation class names.

 spring-core 中的加载类 `SpringFactoriesLoader` 加载指定配置，该类会通过类加载器从 classpath 中搜索所有 `META-INF/spring.factories` 配置文件，然后获取 key 为 `org.springframework.boot.autoconfigure.EnableAutoConfiguration` 部分。

**Java SPI机制：**SPI 的全名为 Service Provider Interface，Java SPI 就是提供这样的一种机制：为某个接口寻找服务的实现的机制，有点类似IOC的思想，就是将装配的控制权移到程序之外，在模块化设计中这个机制很重要。而spring factories就类似于该机制。

**使用场景：**当需要实现一些自定义的Spring Boot Starter，可以通过spring factories的机制，将自己的starter注册到`org.springframework.boot.autoconfigure.EnableAutoConfiguration`命名空间下，这样用户只需要在服务中引入jar包即可以完成自动加载和配置。

**Reference**

- [Spring Boot 自动配置及 Factories 机制总结](https://qidawu.github.io/2017/08/20/spring-factories/)
- [spring boot中的spring factories机制](https://www.jianshu.com/p/7367dddab20d)

### Spring BeanFactoryAware

`BeanFactory`是整个IOC容器的最顶层接口，规定了容器的行为，而实现了该接口，就表明当前类具有`BeanFactory`的能力。

`BeanFactoryAware`接口中只有一个`setBeanFactory`方法。实现了`BeanFactoryAware`接口的类，可以在该`Bean`被加载的过程中获取加载该`Bean`的`BeanFactory`，同时也可以获取这个`BeanFactory`中加载的其它`Bean`。

关键是我们为什么需要通过`BeanFactory`的`getBean`来获取`Bean`呢？Spring已经提供了很多便捷的注入方式，那么通过`BeanFactory`的`getBean`来获取`Bean`有什么好处呢？

**好处：**通过实现`BeanFactoryAware`该接口，在调用者（客户端中），只需要通过一个beanName就可以实现不同实现类的切换。

**Reference**

- https://cloud.tencent.com/developer/article/1749642
- https://juejin.cn/post/6844903661689110542

**具体实现**：

在Knife4j的自定义spring-boot-starter中，为了实现不同服务下的swagger聚合，因此通过实现`BeanFactoryAware`接口，从而在进行聚合的时候，通过获取该Bean。

在大多数情况下，我们应该避免使用任何Aware接口，除非我们需要它们，实现这些接口会将代码耦合到Spring框架。 