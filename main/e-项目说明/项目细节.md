# 项目细节

> 该篇记录一些项目细节

## Spring

### Spring Boot自定义配置自动提示

官方提供的spring-boot-starter的配置项带有自动提示，而自己定义的配置却没有，对开发来说十分不优化，容易打错配置。

**提示原理**

IDE是通过读取配置信息的元数据而实现自动提示的，而元数据在目录META-INF中的spring-configuration-metadata.json 或者 additional-spring-configuration-metadata.json

**具体实现**

在工程下引入依赖：

```xml
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-configuration-processor</artifactId>
    <optional>true</optional>
</dependency>
```

修改IDEA配置：

1. 搜索`Annotation Processor`并设置`Enable annotation processing`
2. 重新编译项目，项目在编译后会自动生成`spring-configuration-metadata.json`文件

**Reference**

- https://docs.spring.io/spring-boot/docs/current/reference/html/configuration-metadata.html

### Spring Factories机制

通过spring.factories实现**解耦拓展机制**。Spring Boot 应用中的”自动配置”是通过 `@EnableAutoConfiguration` 注解进行开启的。`@EnableAutoConfiguration` 可以帮助 Spring Boot 应用将所有符合条件的 `@Configuration` 配置类的 bean 都加载到 Spring IoC 容器中。

> SpringFactoriesLoader loads and instantiates factories of a given type from “META-INF/spring.factories” files which may be present in multiple JAR files in the classpath. The spring.factories file must be in Properties format, where the key is the fully qualified name of the interface or abstract class, and the value is a comma-separated list of implementation class names.

 spring-core 中的加载类 `SpringFactoriesLoader` 加载指定配置，该类会通过类加载器从 classpath 中搜索所有 `META-INF/spring.factories` 配置文件，然后获取 key 为 `org.springframework.boot.autoconfigure.EnableAutoConfiguration` 部分。

**Java SPI机制：**SPI 的全名为 Service Provider Interface，Java SPI 就是提供这样的一种机制：为某个接口寻找服务的实现的机制，有点类似IOC的思想，就是将装配的控制权移到程序之外，在模块化设计中这个机制很重要。而spring factories就类似于该机制。

**使用场景：**当需要实现一些自定义的Spring Boot Starter，可以通过spring factories的机制，将自己的starter注册到`org.springframework.boot.autoconfigure.EnableAutoConfiguration`命名空间下，这样用户只需要在服务中引入jar包即可以完成自动加载和配置。

**Reference**

- [Spring Boot 自动配置及 Factories 机制总结](https://qidawu.github.io/2017/08/20/spring-factories/)
- [spring boot中的spring factories机制](https://www.jianshu.com/p/7367dddab20d)

### Spring BeanFactoryAware

`BeanFactory`是整个IOC容器的最顶层接口，规定了容器的行为，而实现了该接口，就表明当前类具有`BeanFactory`的能力。

`BeanFactoryAware`接口中只有一个`setBeanFactory`方法。实现了`BeanFactoryAware`接口的类，可以在该`Bean`被加载的过程中获取加载该`Bean`的`BeanFactory`，同时也可以获取这个`BeanFactory`中加载的其它`Bean`。

关键是我们为什么需要通过`BeanFactory`的`getBean`来获取`Bean`呢？Spring已经提供了很多便捷的注入方式，那么通过`BeanFactory`的`getBean`来获取`Bean`有什么好处呢？

**好处：**通过实现`BeanFactoryAware`该接口，在调用者（客户端中），只需要通过一个beanName就可以实现不同实现类的切换。

**Reference**

- https://cloud.tencent.com/developer/article/1749642
- https://juejin.cn/post/6844903661689110542

**具体实现**：

在Knife4j的自定义spring-boot-starter中，为了实现不同服务下的swagger聚合，因此通过实现`BeanFactoryAware`接口，从而在进行聚合的时候，通过获取该Bean。

在大多数情况下，我们应该避免使用任何Aware接口，除非我们需要它们，实现这些接口会将代码耦合到Spring框架。 

### @EnableCofigurationProperties注解

「What」@EnableConfigurationProperties注解的作用时：使得@ConfigurationProperties生效。

**@ConfigurationProperties**

使用@Value将Spring ENV bean访问这些属性的时候十分笨重，因此使用更安全的方式，且可以动态控制，因此使用@ConfigurationProperties来进行属性的获取。

基本用法如下，为每个要捕获的外部属性提供一个带有字段的类：

- 前缀定义了哪些外部属性将要绑定到该类的字段上，如`@ConfigurationProperties(prefix = "djj.security")`
- 根据Spring Boot宽松的绑定原则，类的属性名程必须与外部属性匹配
- 类的本身可以是protected
- 类的字段必须有public setter方法

> Spring 宽松绑定规则（relaxed binding）
>
> Spring使用一些宽松的绑定属性规则。如以下变体都将绑定到hostName属性上：
>
> ```properties
> mail.hostName=localhost
> mail.hostname=localhost
> mail.host_name=localhost
> mail.host-name=localhost
> mail.HOST_NAME=localhost
> ```



### yaml配置

多行字符串可以使用`|`保留换行符，也可以使用`>`折叠换行。

例如:

```yaml
        httpUrls: >
          /api-uaa/css/**,
          /api-uaa/images/**,
          /api-uaa/js/**
```

参考：https://www.ruanyifeng.com/blog/2016/07/yaml.html



### 验证码

使用Hutool工具包`cn.hutool.captcha`.

验证码功能位于`cn.hutool.captcha`包中，核心接口为`ICaptcha`，此接口定义了以下方法：

- `createCode` 创建验证码，实现类需同时生成随机验证码字符串和验证码图片
- `getCode` 获取验证码的文字内容
- `verify` 验证验证码是否正确，建议忽略大小写
- `write` 将验证码写出到目标流中其中write方法只有一个`OutputStream`，`ICaptcha`实现类可以根据这个方法封装写出到文件等方法。

`AbstractCaptcha`为一个`ICaptcha`抽象实现类，此类实现了验证码文本生成、非大小写敏感的验证、写出到流和文件等方法，通过继承此抽象类只需实现`createImage`方法定义图形生成规则即可。

使用：

```java
ICaptcha captcha = CaptchaUtil.createLineCaptcha(100, 35, 4, 2);
validateCodeService.saveImageCode(deviceId, captcha.getCode());
captcha.write(response.getOutputStream());
```

